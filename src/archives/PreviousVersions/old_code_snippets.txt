    """Identifies what the hand as an object in front of the camera and draws dots and connect them together.)"""
    # def find_hands(self, img, draw=True):
    #     #  coloring
    #     self.RGBimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    #     self.result = self.hands.process(self.RGBimg)
    #
    #     #  if there are coordinates from the landmarks.
    #     if self.result.multi_hand_landmarks:
    #         for hand_landmarks in self.result.multi_hand_landmarks:
    #             if draw:
    #                 thumb_tip = (
    #                 int(hand_landmarks.landmark[4].x * img.shape[1]), int(hand_landmarks.landmark[4].y * img.shape[0]))
    #                 fingers_center = (int((hand_landmarks.landmark[8].x + hand_landmarks.landmark[12].x +
    #                                        hand_landmarks.landmark[16].x + hand_landmarks.landmark[20].x) / 4 *
    #                                       img.shape[1]),
    #                                   int((hand_landmarks.landmark[8].y + hand_landmarks.landmark[12].y +
    #                                        hand_landmarks.landmark[16].y + hand_landmarks.landmark[20].y) / 4 *
    #                                       img.shape[0]))
    #                 # find the wrist and mark it
    #                 wrist = (
    #                 int(hand_landmarks.landmark[0].x * img.shape[1]), int(hand_landmarks.landmark[0].y * img.shape[0]))
    #
    #                 #  find the angles for the hand
    #                 angles = self.calculateAngles(hand_landmarks)
    #                 for i, angle in enumerate(angles.values()):
    #                     # check if the angle is a float
    #                     if isinstance(angle, float):
    #                         #  draw angle near the wrist
    #                         # this places the text under fps
    #                         cv2.putText(img, f'Angles {i + 1}: {angle:.2f}',
    #                                     (10, img.shape[0] - 20 * (len(angles) - i)),
    #                                     cv2.FONT_HERSHEY_SIMPLEX, 0.5, (140, 0, 255), 1)
    #                 return angles
    #
    #                 # Draws the points on fingers, thumb, and wrist
    #                 cv2.circle(img, thumb_tip, 20, (255, 0, 0), cv2.FILLED)
    #                 cv2.circle(img, fingers_center, 25, (255, 0, 0), cv2.FILLED)
    #                 cv2.circle(img, wrist, 20, (0, 0, 255), cv2.FILLED)
    #
    #                 # draws lines to connect the points
    #                 cv2.line(img, wrist, thumb_tip, (255, 255, 255), 3)  # Line from wrist to thumb
    #                 cv2.line(img, wrist, fingers_center, (255, 255, 255), 3)  # Line from wrist to fingers center
    #                 cv2.line(img, thumb_tip, fingers_center, (255, 255, 255), 3)  # Line from thumb to fingers center
    #
    #     return img

        def findHands(self, img, draw = True):
        """ Will find the hand in the camera"""
        try:
            self.RBGimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            self.result = self.hands.process(self.RBGimg)

            if self.result.multi_hand_landmarks:
                for handlms in self.result.multi_hand_landmarks:
                    self.mpdraw.draw_landmarks(img, handlms, mp.solutions.hands.HAND_CONNECTIONS)
                    if draw:
                        # draw only the thumb (landmark 4)
                        self.drawKeyPoints(img, handlms)
            return img, self.result
        except Exception as e:
            import traceback
            traceback.print_exc()
            print("Error in processing the hand", e)
            return img
            #
            # thumb_x, thumb_y = int(handlms.landmark[4].x * img.shape[1]), int(handlms.landmark[4].y * img.shape[0])
            # cv2.circle(img, (thumb_x, thumb_y), 10, (0, 128, 128), cv2.FILLED)
            #
            # # calculate the average position of the four fingers
            # fingers_x = sum(int(handlms.landmark[i].x * img.shape[1]) for i in range(5, 21)) / 16
            # fingers_y = sum(int(handlms.landmark[i].y * img.shape[0]) for i in range(5, 21)) / 16
            # cv2.circle(img, (int(fingers_x), int(fingers_y)), 10, (0, 0, 255), cv2.FILLED)

            in the handGesture fucntions:         #distance = ((thumb_x - wrist_x) ** 2 + (thumb_y - wrist_y) ** 2) ** 0.5  # this may not be needed for right now


 """Determines whether the palm (palmer side) or the back (dorsal side) of the hand if facing the camera"""
    def handOrientartion(self, lm_list):
        if len(lm_list) < 21:
            return "Unknown"

            thumb_x = lm_list[1][1]
            pinky_x = lm_list[5][1]

            # this should be tested as I forgot whether the window increases from left to right or whatever orientation
            if thumb_x > pinky_x:
                return "Back Size"
            elif thumb_x < pinky_x:
                return "Palm Size"
            else:
                return "Uknown"
        else:
            return "Unknown Orientation"